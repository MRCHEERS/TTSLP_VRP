"""ALNS-based optimizer for TTVRP solutions.

This module provides a simple wrapper around the ALNS library to
improve initial routes generated by the clustered + RL-TSP pipeline.
The optimisation focuses on reordering stop points while keeping the
pairing of depot points fixed.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Dict, List, Iterable

import numpy as np
import pandas as pd

from alns import ALNS, State
from alns.accept import HillClimbing
from alns.select import RandomSelect
from alns.stop import MaxIterations


@dataclass
class VRPState(State):
    """Represents a candidate TTVRP solution."""

    routes: List[List[int]]
    coords: Dict[int, tuple]
    demand: Dict[int, float]
    stop_ids: Iterable[int]
    capacity: float
    unassigned: List[int] = field(default_factory=list)

    def copy(self) -> "VRPState":
        return VRPState(
            routes=[r.copy() for r in self.routes],
            coords=self.coords,
            demand=self.demand,
            stop_ids=self.stop_ids,
            capacity=self.capacity,
            unassigned=self.unassigned.copy(),
        )

    # --- helper utilities -------------------------------------------------
    def route_load(self, route: List[int]) -> float:
        return sum(self.demand.get(i, 0) for i in route if i in self.stop_ids)

    def route_distance(self, route: List[int]) -> float:
        dist = 0.0
        for i in range(len(route) - 1):
            x1, y1 = self.coords[route[i]]
            x2, y2 = self.coords[route[i + 1]]
            dist += np.hypot(x2 - x1, y2 - y1)
        return dist

    # --- mandatory --------------------------------------------------------
    def objective(self) -> float:
        return sum(self.route_distance(r) for r in self.routes)


# -------------------- destroy and repair operators --------------------

def random_removal(state: VRPState, rng: np.random.Generator, fraction: float = 0.2) -> VRPState:
    """Randomly removes a fraction of stop nodes from the solution."""
    new_state = state.copy()
    stops = [n for r in new_state.routes for n in r if n in new_state.stop_ids]
    if not stops:
        return new_state
    num_remove = max(1, int(len(stops) * fraction))
    remove_ids = rng.choice(stops, size=num_remove, replace=False)
    for nid in remove_ids:
        for r in new_state.routes:
            if nid in r:
                r.remove(nid)
                break
    new_state.unassigned.extend(remove_ids)
    return new_state


def greedy_insert(state: VRPState, rng: np.random.Generator) -> VRPState:
    """Greedily inserts unassigned stops into the best position."""
    new_state = state.copy()
    for nid in new_state.unassigned:
        best_route = None
        best_pos = None
        best_cost = float("inf")
        node_demand = new_state.demand.get(nid, 0)

        for ridx, route in enumerate(new_state.routes):
            load = new_state.route_load(route)
            if load + node_demand > new_state.capacity:
                continue
            for pos in range(1, len(route)):
                cand = route[:pos] + [nid] + route[pos:]
                dist = new_state.route_distance(cand)
                if dist < best_cost:
                    best_cost = dist
                    best_route = ridx
                    best_pos = pos
        if best_route is not None:
            new_state.routes[best_route].insert(best_pos, nid)
        else:
            # create a new route if no feasible insertion found
            new_state.routes.append([route[0], nid, route[0]])
    new_state.unassigned.clear()
    return new_state


# ------------------------------ solver ---------------------------------

class ALNSOptimizer:
    """Optimize RL-generated routes using ALNS."""

    def __init__(self, capacity: float = 500):
        self.capacity = capacity

    def optimise(self, df_service: pd.DataFrame, initial_routes: List[List[int]], iterations: int = 1000) -> VRPState:
        """Run ALNS on the given instance.

        Parameters
        ----------
        df_service : pandas.DataFrame
            DataFrame with columns ``service_id``, ``service_type``, ``service_x``,
            ``service_y`` and ``volume``. It must contain the distribution
            centre as well.
        initial_routes : list
            List of routes using ``service_id`` as node identifiers. Routes
            should start and end with the distribution centre id (e.g. ``-1``).
        iterations : int
            Maximum number of ALNS iterations.
        """
        coords = df_service.set_index("service_id")[["service_x", "service_y"]].to_dict("index")
        demand = df_service.set_index("service_id")["volume"].fillna(0).to_dict()
        stop_ids = df_service[df_service["service_type"] == "停靠点"]["service_id"].tolist()

        init_state = VRPState(initial_routes, coords, demand, stop_ids, self.capacity)

        alns = ALNS()
        alns.add_destroy_operator(random_removal)
        alns.add_repair_operator(greedy_insert)

        select = RandomSelect()
        accept = HillClimbing()
        stop = MaxIterations(iterations)

        result = alns.iterate(init_state, select, accept, stop)
        return result.best_state
